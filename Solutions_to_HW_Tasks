//Task 1  
#include <iostream>

int myAbs(int num) 
{
	int absValue;
	absValue = (num >= 0) ? num : -num;
	return absValue;
}
int main()
{
	short input; int minNumber, maxNumber, diff, count, flag;
	minNumber = INT_MAX;
	maxNumber = 0; // no need to take INT_MIN, because if input < 0 it will stop the program;

	count = 0;
	flag = 0;
	std::cout << "Enter an integer number: " << std::endl;;
	while (!(std::cin >> input))
	{
		std::cin.clear(); // reset input
		while (std::cin.get() != '\n') continue; // get rid of bad input
		std::cout << "This input does not work. Enter an integer number in range: " << std::endl;
	}
	while (true)
	{
		if (input >= 0)
		{
			if (input > maxNumber) maxNumber = input;
			if (input < minNumber) minNumber = input;
			count++;
		}
		if (input < 0 && count < 2)
		{
			std::cout << "ERROR! You must enter at least two natural numbers.";
			flag = 2018;
			break;
		}
		else if (input < 0 && count >= 2) break;
		std::cout << "Enter another one: " << std::endl;
		while (!(std::cin >> input))
		{
			std::cin.clear();
			while (std::cin.get() != '\n') continue; 
			std::cout << "This input does not work. Enter an integer number in range: " << std::endl;
		}
	}
	if (flag != 2018)
	{
		diff = minNumber - maxNumber;
		std::cout << "The absolute difference between the smallest and the largest entered numbers is: " << myAbs(diff) << '.';
	}
	return 0;
}
--------------------------------------------------------------------------------------------------------------------------------
//Task 2
#include <iostream>

int SafelyInputDigit(int lowerBound, int upperBound)
{
	int number;
	bool check;
	do 
	{
		check = false;
		std::cout << "Enter a digit: " << std::endl;
		std::cin >> number;

		if (std::cin.fail())
		{
			std::cin.clear();
			std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
			check = true;
			continue;
		}
	} while (((number < lowerBound) || (number > upperBound)) || check);

	return number;
}
int main()
{
	int number;
	short digit;
	std::cout << "Enter an integer number: " << std::endl;

	while (!(std::cin >> number))
	{
		std::cin.clear(); // reset input
		while (std::cin.get() != '\n') continue; // get rid of bad input
		std::cout << "Please enter an integer number, that works: " << std::endl;
	}
	int num = number;

	digit = SafelyInputDigit(0, 9);

	int counter = 0;

	while (number != 0)
	{
		if (number % 10 == digit) counter++;
		number /= 10;
	}
	if (counter == 0) std::cout << "Number " << num << " has no digit " << digit << " in it.";
	else if (counter == 1) std::cout << "Number " << num << " has only one digit " << digit << " in it.";
	else std::cout << "Number " << num << " has " << counter << " times the digit " << digit << " in it.";
	return 0;
}
--------------------------------------------------------------------------------------------------------------------------------
//Task 3
#include <iostream>

int main()
{
	//base 16
	int short firstOperand, secondOperand, operation;

	int base = 16;

	std::cout << "Enter two numbers from 0 to 15 and one from 0 to 3 separated by space:\n";

	while (!(std::cin >> firstOperand >> secondOperand >> operation))
	{
		std::cin.clear(); //reset input
		while (std::cin.get() != '\n') continue; //get rid of bad input
		std::cout << "Please, enter two numbers from 0 to 15 and one from 0 to 3 separated by space:\n";
	}

	bool definitionSet = firstOperand >= 0 && firstOperand <= 15 && operation <= 3 && operation >= 0;

	if (!definitionSet)
	{
		std::cout << "Wrong input";
	}
	else
	{
		/*Since the calculator will be 4 bit - on condition, it is unnecessary for the result variable to be double,
		because the only case in which a floating-point number can be obtained is in the integer division operation,
		but this operation (without casting to double or float) returns integer number. So the result can be at most
		15: 1 = 15 or at least a:b = 0, where a<b and will always be in the allowed values. In this case of division
		we will only check if we divide by 0, which is not allowed.*/

		int result;

		switch (operation)
		{
		case 0:
			std::cout << "The operation is addition and the result is: ";
			result = (firstOperand + secondOperand) % base;
			break;
		case 1:
			std::cout << "The operation is subtraction and the result is: ";
			result = firstOperand - secondOperand;
			if (result < 0) result += 16;
			break;
		case 2:
			std::cout << "The operation is multiplication and the result is: ";
			result = (firstOperand * secondOperand) % base;
			break;
		case 3:
			if (secondOperand != 0)
			{
				std::cout << "The operation is division and the result is: ";
				result = firstOperand / secondOperand;
				break;
			}
			else
			{
				std::cout << "Wrong input";
				return 0;
			}
		}
		std::cout << result<<".\n";
	}
	return 0;
}
--------------------------------------------------------------------------------------------------------------------------------
//Task 4
#include <iostream>

int main()
{
	short side;
	char symbol;
	std::cout << "Enters side length and symbol separated by space: ";
	while (!(std::cin >> side >> symbol))
	{
		std::cin.clear(); // reset input
		while (std::cin.get() != '\n') continue; // get rid of bad input
		std::cout << "Please enter an integer number between 0 and 13" << std::endl;
	}
	if (side <= 13)
	{
		for (int i = 0; i < 12 - side; i++) std::cout << std::endl;
		for (int i = 0; i < side; i++) //loop for rows
		{
			for (int x = 0; x <= 20 - side - 1; x++) //loop for "rectangle" empty spaces by a row
				std::cout << "  ";
			for (int j = (side - 1) - (i + 1); j >= 0; j--) //loop for "triangle" empty spaces
				std::cout << "  ";
			for (int k = 0; k < 4 * i + 1; k++) //loop for upper triangle made of symbols 
				std::cout << symbol;
			std::cout << std::endl;
		}
		for (int i = side - 1; i > 0; i--) //control loop for rows
		{
			for (int x = 0; x <= 20 - side - 2; x++) //etc.
				std::cout << "  ";
			for (int j = 0; j < side - i + 1; j++)
				std::cout << "  ";
			for (int k = 4 * i - 3; k > 0; k--) //loop for lower triangle made of symbols
				std::cout << symbol;
			std::cout << std::endl;
		}
	}
	else
		std::cout << "Wrong input. Number must be between 0 and 13.";
}
--------------------------------------------------------------------------------------------------------------------------------
//Task 5
#include <iostream>

int main()
{
	double x, y;
	std::cout << "Enter the coordinates of the point: ";
	while (!(std::cin >> x >> y))
	{
		std::cin.clear(); //reset input
		while (std::cin.get() != '\n') continue; //get rid of bad input
		std::cout << "Please enter correct abscissa and ordinate of a point:\n";
	}
	const int bigCircRad = 6;
	const int medCircRad = 3;
	const int smallCircRad = 1;

	bool inBigCirc = (x*x + y * y) < bigCircRad*bigCircRad;

	bool inMedCircUp = (x*x + (y - medCircRad)*(y - medCircRad)) < medCircRad*medCircRad;
	bool inMedCircDown = (x*x + (y + medCircRad)*(y + medCircRad)) < medCircRad*medCircRad;

	bool inSmallCircUp = (x*x + (y - medCircRad)*(y - medCircRad)) < smallCircRad*smallCircRad;
	bool inSmallCircDown = (x*x + (y + medCircRad)*(y + medCircRad)) < smallCircRad*smallCircRad;

	bool isUndefined =
		x * x + (y - medCircRad)*(y - medCircRad) == smallCircRad * smallCircRad ||
		x * x + (y + medCircRad)*(y + medCircRad) == smallCircRad * smallCircRad ||
		x * x + (y - medCircRad)*(y - medCircRad) == medCircRad * medCircRad ||
		x * x + (y + medCircRad)*(y + medCircRad) == medCircRad * medCircRad ||
		x * x + y * y == bigCircRad * bigCircRad;

	bool inLeftQuadrant = (x < 0);
	
	if (isUndefined) std::cout << "Undefined";
	else if (inBigCirc)
	{
		if (inLeftQuadrant)
		{
			if ((!inMedCircDown || inSmallCircDown) && !inSmallCircUp) std::cout << "White";
			else std::cout << "Black";
		}
		else
		{
			if ((!inMedCircUp || inSmallCircUp) && !inSmallCircDown) std::cout << "Black";
			else std::cout << "White";
		}
	}
	else std::cout << "Outside";
	return 0;
}
--------------------------------------------------------------------------------------------------------------------------------
//Task 6
#include <iostream>

void printArr(int* arr, size_t size)
{
	std::cout << "Arr = {";
	for (size_t i = 0; i < size; i++)
	{
		if (i == size - 1)
		{
			std::cout << arr[i];
			break;
		}
		std::cout << arr[i] << ", ";
	}
	std::cout << '}';
}

int F(int* arr, size_t const L, int M)
{
	if (M < 0) while (M < 0) M += 5;
	M = M % L; //checking for the condition |M|<L -> unnecessary
	for (int i = 0; i < M; i++)
	{
		int temp = arr[L - 1];
		for (size_t j = L - 1; j > 0; j--)
			arr[j] = arr[j - 1];
		arr[0] = temp;
	}
	return arr[L];
}
int main()
{
	size_t const L = 5;
	int arr[L] = { 6, 5, 6, 0, 3 };
	int arrAfterRotations[L];
	std::cout << "Enter the number of rotations: ";
	int rotationOffset;
	std::cin >> rotationOffset;
	arrAfterRotations[L] = F(arr, L, rotationOffset);
	printArr(arr, L);

	return 0;
}
--------------------------------------------------------------------------------------------------------------------------------
//Task 7
#include <iostream>

size_t len(char* arr, size_t size)
{
	size_t arrLen = 0;
	for (size_t i = 0; i < size; i++)
	{
		if (arr[i] != '\0') arrLen++;
		else break;
	}
	return arrLen;
}

void G(char* B, char* C, const size_t MAX_ARRAY_SIZE)
{
	size_t lenB = len(B, MAX_ARRAY_SIZE);
	size_t lenC = len(C, MAX_ARRAY_SIZE);

	int index = -1;
	size_t currCount = 0;
	size_t maxCount = 0;

	for (size_t i = 0; i < lenB; i++)
	{
		if (B[i] == C[0])
		{
			for (size_t j = 1; j <= lenC; j++) 
			{
				if (B[i + j - 1] == C[j - 1] && i + j - 1 <= lenB)
				{
					if (j == lenC)
					{
						i = i + j;
						j -= lenC;
						currCount++;
						if (currCount > maxCount)
						{
							maxCount = currCount;
							index = i - maxCount * lenC;
						}
					}
				}
			}
			currCount = 0;
		}
	}

	size_t const L = maxCount * lenC;
	char A[100];

	for (size_t i = 0; i < L; i++)
	{
		A[i] = C[i % lenC];

		//Let for example C={b,c,a} and B={B,E,G,I,N,b,c,a,b,c,a,b,c,a,E,N,D}, then
		//A={b,c,a,b,c,a,b,c,a}

		//A[0]=C[0] 0=0 (mod 3), A[1]=C[1] 1=1 (mod 3), A[2]=C[2] 2=2 (mod 3),
		//A[3]=C[0] 3=0 (mod 3), A[4]=C[1] 4=1 (mod 3), A[5]=C[2] 5=2 (mod 3),
		//A[6]=C[0] 6=0 (mod 3), A[7]=C[1] 7=1 (mod 3), A[8]=C[2] 8=2 (mod 3),
		//so generally A[i] = C [i (mod lenC)]
	}

	/*std::cout << "Subtraction of consistently repeating strings C (in array of chars C) in B is: ";
	for (size_t i = 0; i < L; i++) std::cout << A[i];
	std::cout << std::endl;*/

	std::cout << "Index: " << index << std::endl;
	std::cout << "Length: " << maxCount * lenC << std::endl;
}
int main()
{
	const size_t MAX_ARRAY_SIZE = 100;
	char arrC[MAX_ARRAY_SIZE];
	char arrB[MAX_ARRAY_SIZE];

	std::cout << "Enter array \"B\" : ";
	std::cin >> arrB;

	std::cout << "Enter array \"C\" : ";
	std::cin >> arrC;

	G(arrB, arrC, MAX_ARRAY_SIZE);

	return 0;
}
--------------------------------------------------------------------------------------------------------------------------------
//Task 8
#include <iostream>

size_t arrLen(int* arr, size_t size)
{
	size_t arrLen = 0;
	for (size_t i = 0; i < size; i++)
	{
		if (arr[i] != '\0') arrLen++;
		else break;
	}
	return arrLen;
}
bool sim(int matrix[][6], size_t row, size_t col) //checks if the matrix is simplified
{
	for (size_t i = 0; i < row; i++)
	{
		for (size_t j = 0; j < col; j++)
		{
			if (matrix[i][j] / 10 != 0 || matrix[i][j] < 0)
				return false;
		}
	}
	return true;
}
int* convertNumToArr(int M, size_t& lenNum)// converts number M to an array of digits
{
	int* numArr = new int[6];
	for (int i = 0; i < 6; i++)
	{
		numArr[i] = M % 10;
		M /= 10;
		if (M == 0)
		{
			lenNum = i + 1;
			break;
		}
	}
	for (size_t i = 0; i < lenNum / 2; i++) // reverses the array of digits
	{
		int temp = numArr[i];
		numArr[i] = numArr[lenNum - i - 1];
		numArr[lenNum - i - 1] = temp;
	}
	return numArr;
}
bool palindrome(int num)
/*checks if a natural number is palindrome, because	if it is - we will cicle through
the matrix only once from left to right and once from top to bottom */
{
	if (num < 0) return false;
	if (num / 10 == 0) return true;

	size_t n = num;
	short digit;
	size_t rev = 0;
	do
	{
		digit = num % 10;
		rev = (rev * 10) + digit;
		num = num / 10;
	} while (num != 0);
	if (n == rev)return true;
	else return false;
}
int countAppearances(int M, int matrix[][6])
{
	size_t lenNum;
	int* numArr = convertNumToArr(M, lenNum);
	size_t count = 0;
	for (size_t i = 0; i < 6; i++)
	{
		for (size_t j = 0; j < 6; j++)
		{
			if (matrix[i][j] == numArr[0])
			 {
			 for (size_t k = 0; k <= lenNum - 1; k++)
				/*only here we include k=0, when M is with one digit! Because when M is with one digit
				we cycle the matrix	only by rows from left to right and only once*/
			 {
				if (matrix[i][j + k] == numArr[k] && j + k <= 5) //checks rows from left to right
				{
					if (k == lenNum - 1) count++;
				}
				else break;
			 }
			 for (size_t k = 1; k <= lenNum - 1; k++) //k=1
			 {
				if (matrix[i][j - k] == numArr[k] && j - k >= 0 && !palindrome(M)) //checks rows from right to left
				{
					if (k == lenNum - 1) count++;
				}
				else break;
			 }
			 for (size_t k = 1; k <= lenNum - 1; k++) //k=1
			 {
				if (matrix[i + k][j] == numArr[k] && i + k <= 5) //checks columns from top to bottom
				{
					if (k == lenNum - 1) count++;
				}
				else break;
			 }
			 for (size_t k = 1; k <= lenNum - 1; k++) //k=1
			 {
				if (matrix[i - k][j] == numArr[k] && i - k >= 0 && !palindrome(M))//checks columns from bottom to top
				{
					if (k == lenNum - 1) count++;
				}
				else break;
			 }
			}
		}
	}
	delete[] numArr;
	return count;
}
bool validNum(int M) //checks if the number is with six digits ot less and positive
{
	return !(M / 1000000 != 0 || M < 0);
}
int main()
{
	const int ROWS = 6;
	const int COLUMNS = 6;
	int matrix[ROWS][COLUMNS] =
	{ 5,4,3,8,0,6,
	  9,4,5,1,0,2,
	  8,5,8,0,6,1,
	  0,9,6,8,4,2,
	  6,1,0,2,6,1,
	  2,1,8,4,2,6 };
	std::cout << "Enter an integer number: ";
	int M;
	std::cin >> M;
	if (sim(matrix, ROWS, COLUMNS))
	{
		if (!validNum(M)) std::cout << 0;
		else std::cout << countAppearances(M, matrix) << std::endl;
	}
	else std::cout << "The matrix is not simplified.";
	return 0;
}
--------------------------------------------------------------------------------------------------------------------------------
//Task 9
