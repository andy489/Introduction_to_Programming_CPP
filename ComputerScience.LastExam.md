## Повишителен изпит по Увод в програмирането
*СУ  „Климент Охридски“, ФМИ, спец. Компютърни науки, 26.08.2019 г. Вариант А*

**Задача 1.** Дадени са символни низове, съставени от малки латински букви и интервали ( Σ={ 'a' ,'b', ..., 'z', ' ' } ). „Кодиране“ на низ 
s наричаме функция code_s:
Σ→Σ, която замества всяка буква от <img src="https://latex.codecogs.com/svg.latex?\Large&space;s"> с произволна буква от Σ, а буквите от 
Σ, които не се срещат в <img src="https://latex.codecogs.com/svg.latex?\Large&space;s">, оставя непроменени. Да се дефинира функция

void encode ([подходящ тип] s1, [подходящ тип] r1, [подходящ тип] s2, [подходящ тип] r2),

къдети s1, r1, s2 и r2 са символни низове. Функцията да намира кодирането, което преобразува s1 в r1 и, ако такова съществува, да преобразува със същото кодиране низа s2, 
като резултата да запише в r2. Ако такова кодиране не съществува, в r2 да се запише празен низ.

*Примери:*

encode("hello","worrd","love",result) ще запише в result низа "rdvo"

endoce("hello","world","love",result) ще запише в result празния низ

*Решение:*

**Анализ на задачата:**

Символните низове s1 и r1 ни дават информация за това коя буква с коя се заменя при кодирането. Ако вземем примера с "hello" и кодирания му вариант "worrd" - на първо място забелязваме, че са с еднакви дължини, тъй като ако не бяха, то нямаше да съществува такова кодиране. На второ място забелязваме, че 'h' се замества с 'w', 'e' се замества с 'o', 'l' се замества с 'r' и т.н. и тук е момента, в който трябва да си дадем сметка, че ако веднъж дадена буква се замества с някоя друга, то ако по натам в низа се появи отново същата буква - в съответния кодиран низ трябва на неината позиция отново да е буквата с която се е заместила първия път, иначе такова кодиране отново няма да съществува. Това ни навежда на мисълта, че ще е най-добре да отстраним този казус с това дали съществува или не подобно кодиране с една булева функция която връща true или false според това дали съществува или не подобно кодиране. След като вече разполагаме с такава функция, ако тя връща true, може да продължим с кодирането, защото вече ще сме сигурни, че за всяка буква от първоначалния низ съответства точно една буква от азбуката, тоест функцията encode не е нито *инекция* нито *сюрекция*. За оптимизация, докато правим проверката ще сухраняваме в масив с дължина 26+1 (броя на буквите + празната клетка) на съответната позиция - кодиращия и символ. Например на позиция с индекс 0 в масива (първата) отговаря буквата 'а', на позиция с индекс 1 (втората) - отговаря буквата 'b' и т.н., като накрая сме си оставили едно място и за празната клетка.

```cpp
#include <iostream>
#include <iostream>
size_t myStrlen(char* str)
{       /* в C++ всеки символен низ завършва със специален знак '\0' - терминираща нула,
	която показва къде е края на низа. Използвайки този знак, ние отброяваме с цикъл
	вимволите преди него и по този начин извеждаме дължината на символния низ */
	size_t len = 0;;
	while (str[len] != '\0') len++;
	return len;
}
bool isLower(char ch)
{       //помощна функция, която проверява дали даден символ е малка латинска буква 
	if ('a' <= ch && ch <= 'z') return true;
	else return false;
}
bool existCode(char* s1, char* r1, char* &ptr)
{	//на адреса &ptr ще върнем пойнрът към динамично заделения масив 
	//където сме съхранили кой символ с какъв се кодира
	size_t len_s1 = myStrlen(s1);
	size_t len_r1 = myStrlen(r1);

	//ако дължините на низа s1 и кодирания му низ r1 не съвпадат, 
	//значи такова кодиране не съществува 
	if (len_s1 != len_r1) return false;

	// Създаваме си един масим с големина 26 + 1, това са броя на малките 
	// латински букви плюс празното разстояние 
	char* arr = new char[26 + 1];//създаваме го динамично, за да може да го ползваме после 
	//запълваме го с някой от непозволените символи, например някое число '8' - като символ
	memset(arr, '8', 26 + 1);
	ptr = arr;
	//щом сме тук, значи дължините са еднакви и може да въртим цикъл до която и да е от тях
	for (size_t i = 0; i < len_s1; i++)
	{
		if (isLower(s1[i]))
		{
			if (arr[(int)s1[i] - 97] == '8')//ако на този символ от s1 няма кодиращ символ
			{//слагаме кодиращоия му символ в масива arr на позиция отговаряща 
		         //на мястото на символа в азбуката, което е символа минус 97-ASCII 
			 //кода на първата буква от азбуката
			arr[(int)s1[i] - 97] = r1[i];								  
			}
			else
			{//в противен случай такъв символ вече е сложен и ако новия,
			 //който се опитваме да сложим е различен, значи такова кодиране не съществува
				if (r1[i] != arr[(int)s1[i] - 97]) return false;
			}
		}
		else 
		// след като не е малка латинска буква, то тогава ще е празната клетка,
		// тъй като по условие низовете са само малки латински букви или празната клетка 
		{
			if (arr[26] == '8')
			{//празната клетка е с фиксирана позиция 26-последната в масива arr 
				arr[26] = r1[i]; 
			}
			else if (arr[26] != r1[i]) return false;
		}
	}//ако сме изциклили веднъж през цялата дължина -> съществува такова кодиране
	return true; 
}
int main()
{
	char s1[] = "hello";
	char r1[] = "worrd";

	char s2[] = "love";

	size_t len = myStrlen(s2);
	char* result = new char[len + 1];
	for (size_t i = 0; i < len; i++) result[i] = s2[i];
	result[len] = '\0';	
	//ако съществува такова кодиране, то най-удобно ще е дефолтната стойност
	//на кодирания низ да е същата като низа, който ще кодираме. (Защо?) 
	char* ptr;
	if (existCode(s1, r1, ptr))
	{
		for (size_t i = 0; i < myStrlen(s2); i++)
		{
			if (isLower(s2[i]))
			{
				if (ptr[(int)s2[i] - 97] != '8')
				{
					result[i] = ptr[(int)s2[i] - 97];
				}
			}
			else
			{ //щом сме тук значи символа не е малка буква и от условието следва, 
		          //че е празната клетка, която се кодира със символ с фиксирана позиция 
		          //в масива arr, за който знаем че ptr сочи към него
				result[i] = ptr[26];
			}
		}
		std::cout << "Coded word is: " << result << '\n';
	}
	else
	{
		delete result;
		result = new char[1];
		result[0] = '\0';
		std::cout << "No such encoding exists!\n";
		std::cout << "The empty string: " << result << std::endl;
	}
	delete[] ptr;
	delete[] result;
	return 0;
}

```
