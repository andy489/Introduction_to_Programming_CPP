## Повишителен изпит по Увод в програмирането
*СУ  „Климент Охридски“, ФМИ, спец. Компютърни науки, 26.08.2019 г. Вариант А*

**Задача 1.** Дадени са символни низове, съставени от малки латински букви и интервали ( Σ={ 'a' ,'b', ..., 'z', ' ' } ). „Кодиране“ на низ 
s наричаме функция code_s:
Σ→Σ, която замества всяка буква от <img src="https://latex.codecogs.com/svg.latex?\Large&space;s"> с произволна буква от Σ, а буквите от 
Σ, които не се срещат в <img src="https://latex.codecogs.com/svg.latex?\Large&space;s">, оставя непроменени. Да се дефинира функция

void encode ([подходящ тип] s1, [подходящ тип] r1, [подходящ тип] s2, [подходящ тип] r2),

къдети s1, r1, s2 и r2 са символни низове. Функцията да намира кодирането, което преобразува s1 в r1 и, ако такова съществува, да преобразува със същото кодиране низа s2, 
като резултата да запише в r2. Ако такова кодиране не съществува, в r2 да се запише празен низ.

*Примери:*

encode("hello","worrd","love",result) ще запише в result низа "rdvo"

endoce("hello","world","love",result) ще запише в result празния низ

*Решение:*

**Анализ на задачата:**

Символните низове s1 и r1 ни дават информация за това коя буква с коя се заменя при кодирането. Ако вземем примера с "hello" и кодирания му вариант "worrd" - на първо място забелязваме, че са с еднакви дължини, тъй като ако не бяха, то нямаше да съществува такова кодиране. На второ място забелязваме, че 'h' се замества с 'w', 'e' се замества с 'o', 'l' се замества с 'l' и т.н. и тук е момента, в който трябва да си дадем сметка, че ако веднъж дадена буква се замества с някоя друга, то ако по натам в низа се появи отново същата буква - в съответния кодиран низ трябва на неината позиция отново да е буквата с която се е заместила първия път, иначе такова кодиране отново няма да съществува. Това ни навежда на мисълта, че ще е най-добре да отстраним този казус с това дали съществува или не подобно кодиране с една булева функция която връща true или false според това дали съществува или не подобно кодиране. След като вече разполагаме с такава функция, ако тя връща true, може да продължим с кодирането, защото вече ще сме сигурни, че за всяка буква от първоначалния низ съответства точно една буква от азбуката, тоест функцията encode не е нито *инекция* нито *сюрекция*. За оптимизация, докато правим проверката ще сухраняваме в масив с дължина 26+1 (броя на буквите + празната клетка) на съответната позиция - кодиращия и символ. Например на позиция с индекс 0 в масива (първата) отговаря буквата 'а', на позиция с индекс 1 (втората) - отговаря буквата 'b' и т.н., като накрая сме си оставили едно място и за празната клетка.

```cpp
#include <iostream>

```
