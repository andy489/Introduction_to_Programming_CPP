## Повишителен изпит по Увод в програмирането
*СУ  „Климент Охридски“, ФМИ, спец. Компютърни науки, 26.08.2019 г. Вариант А*

**Задача 1.** Дадени са символни низове, съставени от малки латински букви и интервали ( Σ={ 'a' ,'b', ..., 'z', ' ' } ). „Кодиране“ на низ s наричаме функция code_s: Σ→Σ, която замества всяка буква от s с произволна буква от Σ, а буквите от Σ, които не се срещат в s, оставя непроменени. Да се дефинира функция

void encode ([подходящ тип] s1, [подходящ тип] r1, [подходящ тип] s2, [подходящ тип] r2),

къдетo s1, r1, s2 и r2 са символни низове. Функцията да намира кодирането, което преобразува s1 в r1 и, ако такова съществува, да преобразува със същото кодиране низа s2, като резултата да запише в r2. Ако такова кодиране не съществува, в r2 да се запише празен низ.

*Примери:*

encode("hello","worrd","love",result) ще запише в result низа "rdvo"

endoce("hello","world","love",result) ще запише в result празния низ

*Решение:*

**Анализ на задачата:**

Символните низове s1 и r1 ни дават информация за това коя буква с коя се заменя при кодирането. Ако вземем примера с "hello" и кодирания му вариант "worrd" - на първо място забелязваме, че са с еднакви дължини, тъй като ако не бяха, то нямаше да съществува такова кодиране. На второ място забелязваме, че 'h' се замества с 'w', 'e' се замества с 'o', 'l' се замества с 'r' и т.н. и тук е момента, в който трябва да си дадем сметка, че ако веднъж дадена буква се замества с някоя друга, то ако по натам в низа се появи отново същата буква - в съответния кодиран низ трябва на неината позиция отново да е буквата с която се е заместила първия път, иначе такова кодиране отново няма да съществува. Това ни навежда на мисълта, че ще е най-добре да отстраним този казус с това дали съществува или не подобно кодиране с една булева функция която връща true или false според това дали съществува или не подобно кодиране. След като вече разполагаме с такава функция, ако тя връща true, може да продължим с кодирането, защото вече ще сме сигурни, че за всяка буква от първоначалния низ съответства точно една буква от азбуката, тоест функцията encode не е нито *инекция* нито *сюрекция*. За оптимизация, докато правим проверката ще сухраняваме в масив с дължина 26+1 (броя на буквите + празната клетка) на съответната позиция - кодиращия и символ. Например на позиция с индекс 0 в масива (първата) отговаря буквата 'а', на позиция с индекс 1 (втората) - отговаря буквата 'b' и т.н., като накрая сме си оставили едно място и за празната клетка.

```cpp
#include <iostream>
size_t myStrlen(char* str)
{       /* в C++ всеки символен низ завършва със специален знак '\0' - терминираща нула,
	която показва къде е края на низа. Използвайки този знак, ние отброяваме с цикъл
	вимволите преди него и по този начин извеждаме дължината на символния низ */
	size_t len = 0;;
	while (str[len] != '\0') len++;
	return len;
}
bool isLower(char ch)
{       //помощна функция, която проверява дали даден символ е малка латинска буква 
	if ('a' <= ch && ch <= 'z') return true;
	else return false;
}
bool existCode(char* s1, char* r1, char* &ptr)
{	// на адреса &ptr ще върнем пойнрът към динамично заделения масив 
	// където сме съхранили кой символ с какъв се кодира
	size_t len_s1 = myStrlen(s1);
	size_t len_r1 = myStrlen(r1);

	//ако дължините на низа s1 и кодирания му низ r1 не съвпадат, 
	//значи такова кодиране не съществува 
	if (len_s1 != len_r1)return false;

	// Създаваме си един масим с големина 26 + 1, това са броя на малките 
	// латински букви плюс празното разстояние 
	char* arr = new char[26 + 1];//създаваме го динамично, за да може да го ползваме после 
	//запълваме го с някой от непозволените символи, например някое число '8' - като символ
	memset(arr, '8', 26 + 1);
	ptr = arr;
	//щом сме тук, значи дължините са еднакви и може да въртим цикъл до която и да е от тях
	for (size_t i = 0; i < len_s1; i++)
	{
		if (isLower(s1[i]))
		{
			if (arr[(int)s1[i] - 97] == '8')//ако на този символ от s1 няма кодиращ символ
			{//слагаме кодиращоия му символ в масива arr на позиция отговаряща 
		         //на мястото на символа в азбуката, което е символа минус 97-ASCII 
			 //кода на първата буква от азбуката
			arr[(int)s1[i] - 97] = r1[i];								  
			}
			else
			{//в противен случай такъв символ вече е сложен и ако новия,
			 //който се опитваме да сложим е различен, значи такова кодиране не съществува
				if (r1[i] != arr[(int)s1[i] - 97]) return false;
			}
		}
		else 
		// след като не е малка латинска буква, то тогава ще е празната клетка,
		// тъй като по условие низовете са само малки латински букви или празната клетка 
		{
			if (arr[26] == '8')
			{//празната клетка е с фиксирана позиция 26-последната в масива arr 
				arr[26] = r1[i]; 
			}
			else if (arr[26] != r1[i]) return false;
		}
	}//ако сме изциклили веднъж през цялата дължина -> съществува такова кодиране
	return true; 
}

void encode(char s1[], char r1[], char s2[])
{
	size_t len = myStrlen(s2);
	char* result = new char[len + 1];
	for (size_t i = 0; i < len; i++) result[i] = s2[i];
	result[len] = '\0';
	// ако съществува такова кодиране, то най-удобно
	// ще е дефолтната стойност на кодирания низ да е
	// същата като низа, който ще кодираме. (Защо?) */
	char* ptr;
	if (existCode(s1, r1, ptr))
	{
		for (size_t i = 0; i < myStrlen(s2); i++)
		{
			if (isLower(s2[i]))
			{
				if (ptr[(int)s2[i] - 97] != '8')
				{
					result[i] = ptr[(int)s2[i] - 97];
				}
			}
			else
			{ //щом сме тук значи символа не е малка буква и от условието следва, 
			  //че е празната клетка, която се кодира със символ с фиксирана позиция 
			  //в масива arr, за който знаем че ptr сочи към него
				result[i] = ptr[26];
			}
		}
		std::cout << "Coded word is: " << result << '\n';
	}
	else
	{
		delete result;
		result = new char[1];
		result[0] = '\0';
		std::cout << "No such encoding exists!\n";
		std::cout << "The empty string: " << result << std::endl;
	}
	delete[] ptr; // изтриваме масива с информацията за декриптирането
	delete[] result; // изтриваме резултата след като сме го принтирали на конзолата
}

int main()
{
	char s1[] = "hello";
	char r1[] = "worrd";
	char s2[] = "love";
	encode(s1, r1, s2); // четвърти аргумент е излишен	
	return 0;
}
```

**Задача 2.** Дадена е матрица от символи char C[3][3], и масив от n символни низа words, като всеки символен ни е с големина най-много 9 символа. Казваме, че една дума w може да се прочете в матрицата C, ако може да се намери последователност от съседни (споделящи стена) клетки в C, чиито букви взети в този ред образуват думата w. Да се напише функция:

bool crossword ([подходящ тип] C, [подходящ тип] words, unsigned n)

Функцията да връща истина тогава и само тогава, когато всяка от думите в масива words може да се прочете в матрицата.

*Пример:*

c|a|t
---|---|---
**w**|**h**|**o**
**w**|**i**|**n**

При матрицата по-горе, функцията ще върне истина за масива с низове "cat", "what" и "not", но не и за масива с низове "cat, "hot" и "chat".

*Решение:*

```cpp
#define N 3 
#include <iostream>
size_t myStrlen(char* str)
{
	size_t len = 0;;
	while (str[len] != '\0') len++;
	return len;
}
/*Функция, която проверява дали дадена дума съществува в матрицата от букви,
като стартира от първото срещане на първата буква от търсената дума в матрицата
от букви. С level отбелязваме кога ще сме изчерпали думата, а x и y са текущата
позиция в буквената матрица*/
bool findWord(char C[3][3], char* word, int x, int y, int length)
{
	int len = myStrlen(word);
	// Ако сме достигнали дължината на думата, значи сме намерили такава дума 
	if (length == len)	return true;

	// Дефиниционно множество. Ако излезем извън буквената таблица връщаме false
	if (x < 0 || y < 0 || x >= 3 || y >= 3)	return false;

	// Знаем, че сме съвпаднали с тази буква, защото първитре x и y ще са проверените i и j
	if (C[x][y] == word[length])
	{	// Търсим съвпадение в допустимите клетки по правилото
		bool rest = findWord(C, word, x - 1, y, length + 1) ||
			findWord(C, word, x + 1, y, length + 1) ||
			findWord(C, word, x, y - 1, length + 1) ||
			findWord(C, word, x, y + 1, length + 1);
		return rest;
	}
	else return false; // Не сме намерили съвпадение тогава false 
}

//Функция, която проверява дали дадена дума я има в матрицата по дадените правила
bool matchWord(char C[3][3], char* word)
{
	int len = myStrlen(word);
	// Обхождаме матрицата и търсим съвпадение с първата буква на думата 
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < N; j++)
		{   // Ако имаме съвпадение, то проверяваме с рекурсията дали може да довършим думата			
			if (C[i][j] == word[0])
			{
				if (findWord(C, word, i, j, 0)) return true;
			}
		}
	}
	return false;
}
bool crossword(char C[3][3], char words[][10], unsigned countWords)
{
	for (size_t i = 0; i < countWords; i++)
	{
		char currentWord[10];
		size_t j = 0;
		do
		{
			currentWord[j] = words[i][j];
			j++;
		} while (words[i][j] != '\0');
		currentWord[j] = '\0';
		j = 0; // връщаме брояча на нула, за да може да запишем коректно следващата дума
		if (!matchWord(C, currentWord))
		{
			return false;
		}
	}
	return true;
}

int main()
{
	char C[3][3] = { 'c','a','t',
					 'w','h','o',
					 'w','i','n' };
	// с дължина 10, за да има място и за терминиращата нула
	char words[][10] = { "cat",
			     "what",
			     "not" };
	unsigned countWords = sizeof(words) / sizeof(words[0]);

	crossword(C, words, countWords) ? std::cout << "true" : std::cout << "false";
	return 0;
}
```
**КОМЕНТАР:**

Така както е зададено условието на задачата, не е еднозначно дефинирано дали при прочитането на дадена дума чрез матрицата са допустими *застъпвания*, където „*застъпвне*“ ще дефинираме като преминаване през една и съща буква повече от един път (*спазвайки посочените в условието правила*). В кода имплементиран по горе както се вижда никъде не маркираме дадена буква след прочитането ѝ и следователно сме допуснали б.о.о., че са позволени застъпвания. Ако искаме да забраним застъпванията ще трябва когато намерим съвпадение с началната буква на дадена дума, във функцията, която търси съвпадение на цялата дума да маркираме буквата като *прочетена*, след което да я отмаркирваме.

*Имплементиране на задачата без застъпване (промени единствено на редове 25,26 и 32):*

```cpp
#define N 3 
#include <iostream>
size_t myStrlen(char* str)
{
	size_t len = 0;;
	while (str[len] != '\0') len++;
	return len;
}
/*Функция, която проверява дали дадена дума съществува в матрицата от букви,
като стартира от първото срещане на първата буква от търсената дума в матрицата
от букви. С level отбелязваме кога ще сме изчерпали думата, а x и y са текущата
позиция в буквената матрица*/
bool findWord(char C[3][3], char* word, int x, int y, int length)
{
	int len = myStrlen(word);
	// Ако сме достигнали дължината на думата, значи сме намерили такава дума 
	if (length == len)	return true;

	// Дефиниционно множество. Ако излезем извън буквената таблица връщаме false
	if (x < 0 || y < 0 || x >= 3 || y >= 3)	return false;

	// Знаем, че сме съвпаднали с тази буква, защото първитре x и y ще са проверените i и j
	if (C[x][y] == word[length])
	{	// Търсим съвпадение в допустимите клетки по правилото
		char temp = C[x][y]; // съхраняваме буквата от клетката
		C[x][y] = '#'; // Маркираме клетката като посетена
		bool rest = findWord(C, word, x - 1, y, length + 1) ||
			findWord(C, word, x + 1, y, length + 1) ||
			findWord(C, word, x, y - 1, length + 1) ||
			findWord(C, word, x, y + 1, length + 1);
		// Отмаркираме клетката като непосетена отново
		C[x][y] = temp;
		return rest;
	}
	else return false; // Не сме намерили съвпадение тогава false 
}

//Функция, която проверява дали дадена дума я има в матрицата по дадените правила
bool matchWord(char C[3][3], char* word)
{
	int len = myStrlen(word);

	// Ако дължината на думата е по-голяма от всички позиции в матрицата
	if (len > N * N) return false;

	// Обхождаме матрицата и търсим съвпадение с първата буква на думата 
	for (int i = 0; i < N; i++)
	{
		for (int j = 0; j < N; j++)
		{   // Ако имаме съвпадение, то проверяваме с рекурсията дали може да довършим думата			
			if (C[i][j] == word[0])
			{
				if (findWord(C, word, i, j, 0)) return true;
			}
		}
	}
	return false;
}
bool crossword(char C[3][3], char words[][10], unsigned countWords)
{
	for (size_t i = 0; i < countWords; i++)
	{
		char currentWord[10];
		size_t j = 0;
		do
		{
			currentWord[j] = words[i][j];
			j++;
		} while (words[i][j] != '\0');
		currentWord[j] = '\0';
		j = 0; // връщаме брояча на нула, за да може да запишем коректно следващата дума
		if (!matchWord(C, currentWord))
		{
			return false;
		}
	}
	return true;
}

int main()
{
	char C[3][3] = { 'c','a','t',
					 'w','h','o',
					 'w','i','n' };
	// с дължина 10, за да има място и за терминиращата нула
	char words[][10] = { "cahota",
						 "what",
						 "not" };
	unsigned countWords = sizeof(words) / sizeof(words[0]);

	crossword(C, words, countWords) ? std::cout << "true" : std::cout << "false";
	return 0;
}

```
