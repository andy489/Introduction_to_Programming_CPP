#include <iostream>

unsigned progression(int a[], unsigned n) {
    if (n == 0) return 0; //частен случай - празната редица
    //временен и максимален брояч за дължината на растящата подредица
    unsigned currCount(0), maxCount(0);
    for (unsigned i = 0; i < n; i++) {
        for (unsigned j = i; j < n; j++) {
            if (n - i <= maxCount) goto end;/* оптимизираме кода, ако максималната 
			растяща подредица до тоя момент е с X елемента, а до края на 
			масива/редицта има по-малко от X елемента, то няма смисъл да 
			продължаваме да търсим по-дълга растяща редица*/
            if (a[j] < a[j + 1]) currCount++; /* ако редицата е растяща (както 
			се иска в условието) - инкрементираме брояча*/
            else // в противен случай
            {
                i = j; /* прескачаме до мястото до където се е счупила растящата 
				редица и започваме да търсим от новото място*/
                break;
            }
        }
        if (currCount > maxCount) maxCount = currCount;
        //ако временния брояч е станал по-голям от максималния - новия максимален става временния
        currCount = 0; // рестартираме временния брояч
    }
    end:
    return maxCount + 1;
}

int main() {
    int a[] = {1, 3, 1, 2, 3, 1};
    unsigned n = sizeof(a) / sizeof(a[0]); // намираме дължината на масива

    std::cout << progression(a, n);
    return 0;
}
